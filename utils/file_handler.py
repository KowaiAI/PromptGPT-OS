"""
# PromptGPT OS - File Management System
# Developed by: https://github.com/KowaiAI
# Copyright (c) 2025 KowaiAI. All rights reserved.
# 
# This file contains proprietary file handling and management code.
# Unauthorized copying, modification, or distribution is prohibited.
# 
# Watermark: PROMPTGPT_OS_KOWAI_AI_2025_FILE_CORE
"""

import os
import json
from datetime import datetime
from rich.console import Console

console = Console()

class FileHandler:
    """Handles file operations for prompt saving and management"""
    
    def __init__(self):
        self.output_dir = "generated_prompts"
        self.ensure_output_directory()
    
    def ensure_output_directory(self):
        """Create output directory if it doesn't exist"""
        try:
            os.makedirs(self.output_dir, exist_ok=True)
        except Exception as e:
            console.print(f"[red]Warning: Could not create output directory: {str(e)}[/red]")
            self.output_dir = "."
    
    def save_prompt(self, prompt_content, category, subcategory):
        """Save generated prompt to file"""
        try:
            # Generate filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{category}_{subcategory}_{timestamp}.txt"
            filepath = os.path.join(self.output_dir, filename)
            
            # Prepare content with metadata
            content = self.format_prompt_file(prompt_content, category, subcategory)
            
            # Write to file
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return filepath
            
        except Exception as e:
            console.print(f"[red]Error saving prompt: {str(e)}[/red]")
            # Fallback: try to save in current directory
            try:
                fallback_filename = f"prompt_{timestamp}.txt"
                with open(fallback_filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                return fallback_filename
            except Exception as e2:
                console.print(f"[red]Failed to save prompt: {str(e2)}[/red]")
                return None
    
    def format_prompt_file(self, prompt_content, category, subcategory):
        """Format the prompt content for file output"""
        header = f"""
PromptGPT OS - Generated AI Prompt
{'=' * 50}
Category: {category.title()}
Subcategory: {subcategory.title()}
Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
{'=' * 50}

PROMPT:
{'-' * 20}
"""
        
        footer = f"""
{'-' * 20}

Instructions:
1. Copy the prompt above (between the dashes)
2. Paste it into your preferred AI tool (ChatGPT, Claude, etc.)
3. Adjust as needed for your specific use case

Generated by PromptGPT OS
"""
        
        return header + prompt_content + footer
    
    def save_session_data(self, session_data):
        """Save session data for recovery purposes"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"session_{timestamp}.json"
            filepath = os.path.join(self.output_dir, filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            return filepath
            
        except Exception as e:
            console.print(f"[red]Error saving session data: {str(e)}[/red]")
            return None
    
    def load_session_data(self, filepath):
        """Load session data from file"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            console.print(f"[red]Error loading session data: {str(e)}[/red]")
            return None
    
    def list_saved_prompts(self):
        """List all saved prompt files"""
        try:
            files = []
            for filename in os.listdir(self.output_dir):
                if filename.endswith('.txt') and not filename.startswith('session_'):
                    filepath = os.path.join(self.output_dir, filename)
                    stat = os.stat(filepath)
                    files.append({
                        'filename': filename,
                        'filepath': filepath,
                        'size': stat.st_size,
                        'modified': datetime.fromtimestamp(stat.st_mtime)
                    })
            
            # Sort by modification time (newest first)
            files.sort(key=lambda x: x['modified'], reverse=True)
            return files
            
        except Exception as e:
            console.print(f"[red]Error listing saved prompts: {str(e)}[/red]")
            return []
    
    def read_prompt_file(self, filepath):
        """Read a saved prompt file"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            console.print(f"[red]Error reading prompt file: {str(e)}[/red]")
            return None
    
    def delete_prompt_file(self, filepath):
        """Delete a saved prompt file"""
        try:
            os.remove(filepath)
            return True
        except Exception as e:
            console.print(f"[red]Error deleting prompt file: {str(e)}[/red]")
            return False
    
    def cleanup_old_files(self, days_old=30):
        """Clean up old prompt files"""
        try:
            cutoff_time = datetime.now().timestamp() - (days_old * 24 * 60 * 60)
            deleted_count = 0
            
            for filename in os.listdir(self.output_dir):
                filepath = os.path.join(self.output_dir, filename)
                if os.path.isfile(filepath):
                    file_time = os.path.getmtime(filepath)
                    if file_time < cutoff_time:
                        try:
                            os.remove(filepath)
                            deleted_count += 1
                        except Exception:
                            pass
            
            return deleted_count
            
        except Exception as e:
            console.print(f"[red]Error during cleanup: {str(e)}[/red]")
            return 0
    
    def export_prompts_json(self, output_file="exported_prompts.json"):
        """Export all prompts to a single JSON file"""
        try:
            prompts = []
            files = self.list_saved_prompts()
            
            for file_info in files:
                content = self.read_prompt_file(file_info['filepath'])
                if content:
                    prompts.append({
                        'filename': file_info['filename'],
                        'content': content,
                        'created': file_info['modified'].isoformat(),
                        'size': file_info['size']
                    })
            
            export_data = {
                'export_date': datetime.now().isoformat(),
                'total_prompts': len(prompts),
                'prompts': prompts
            }
            
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            return output_file
            
        except Exception as e:
            console.print(f"[red]Error exporting prompts: {str(e)}[/red]")
            return None
